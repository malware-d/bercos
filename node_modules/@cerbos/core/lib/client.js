"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = exports._removeInstrumenter = exports._addInstrumenter = void 0;
const fromProtobuf_1 = require("./convert/fromProtobuf");
const toProtobuf_1 = require("./convert/toProtobuf");
const errors_1 = require("./errors");
const instrumenters = new Set();
/** @internal */
function _addInstrumenter(instrumenter) {
    instrumenters.add(instrumenter);
}
exports._addInstrumenter = _addInstrumenter;
/** @internal */
function _removeInstrumenter(instrumenter) {
    instrumenters.delete(instrumenter);
}
exports._removeInstrumenter = _removeInstrumenter;
/**
 * Base implementation of a client for interacting with the Cerbos policy decision point server.
 *
 * @public
 */
class Client {
    transport;
    options;
    /** @internal */
    constructor(transport, options) {
        this.transport = transport;
        this.options = options;
        for (const instrumenter of instrumenters) {
            this.transport = instrumenter(this.transport);
        }
    }
    /**
     * Add policies, or update existing policies.
     *
     * @remarks
     * Requires
     *
     * - the client to be configured with {@link Options.adminCredentials},
     *
     * - the Cerbos policy decision point server to be configured with the {@link https://docs.cerbos.dev/cerbos/latest/api/admin_api | admin API} enabled, and
     *
     * - a dynamic {@link https://docs.cerbos.dev/cerbos/latest/configuration/storage | storage backend}.
     *
     * @example
     * Create a policy in code:
     *
     * ```typescript
     * await cerbos.addOrUpdatePolicies({
     *   policies: [{
     *     resourcePolicy: {
     *       resource: "document",
     *       version: "1",
     *       rules: [{
     *         actions: ["*"],
     *         effect: Effect.ALLOW,
     *         roles: ["ADMIN"],
     *       }],
     *     },
     *   }],
     * });
     * ```
     *
     * @example
     * Load a policy from a YAML or JSON file with {@link @cerbos/files#readPolicy}:
     *
     * ```typescript
     * import { readPolicy } from "@cerbos/files";
     *
     * await cerbos.addOrUpdatePolicies({
     *   policies: [await readPolicy("path/to/policy.yaml")],
     * });
     * ```
     *
     * @example
     * Load policies and schemas from a directory with {@link @cerbos/files#readDirectory}:
     *
     * ```typescript
     * import { readDirectory } from "@cerbos/files";
     *
     * const { policies, schemas } = await readDirectory("path/to/directory");
     *
     * await cerbos.addOrUpdateSchemas({ schemas });
     * await cerbos.addOrUpdatePolicies({ policies });
     * ```
     */
    async addOrUpdatePolicies(request, options) {
        await this.admin("addOrUpdatePolicy", (0, toProtobuf_1.addOrUpdatePoliciesRequestToProtobuf)(request), options);
    }
    /**
     * Add schemas to be used for validating principal or resource attributes, or update existing schemas.
     *
     * @remarks
     * Requires
     *
     * - the client to be configured with {@link Options.adminCredentials},
     *
     * - the Cerbos policy decision point server to be configured with the {@link https://docs.cerbos.dev/cerbos/latest/api/admin_api | admin API} enabled, and
     *
     * - a dynamic {@link https://docs.cerbos.dev/cerbos/latest/configuration/storage | storage backend}.
     *
     * @example
     * Create a schema in code:
     *
     * ```typescript
     *
     * await cerbos.addOrUpdateSchemas({
     *   schemas: [{
     *     id: "document.json",
     *     definition: {
     *       type: "object",
     *       properties: {
     *         owner: { type: "string" }
     *       }
     *     },
     *   }],
     * });
     * ```
     *
     * @example
     * Load a schema from a JSON file with {@link @cerbos/files#readSchema}:
     *
     * ```typescript
     * import { readSchema } from "@cerbos/files";
     *
     * await cerbos.addOrUpdateSchemas({
     *   schemas: [await readSchema("_schemas/path/to/schema.json")],
     * });
     * ```
     *
     * @example
     * Load policies and schemas from a directory with {@link @cerbos/files#readDirectory}:
     *
     * ```typescript
     * import { readDirectory } from "@cerbos/files";
     *
     * const { policies, schemas } = await readDirectory("path/to/directory");
     *
     * await cerbos.addOrUpdateSchemas({ schemas });
     * await cerbos.addOrUpdatePolicies({ policies });
     * ```
     */
    async addOrUpdateSchemas(request, options) {
        await this.admin("addOrUpdateSchema", (0, toProtobuf_1.addOrUpdateSchemasRequestToProtobuf)(request), options);
    }
    /**
     * Check a principal's permissions on a resource.
     *
     * @example
     * ```typescript
     * const decision = await cerbos.checkResource({
     *   principal: {
     *     id: "user@example.com",
     *     roles: ["USER"],
     *     attr: { tier: "PREMIUM" },
     *   },
     *   resource: {
     *     kind: "document",
     *     id: "1",
     *     attr: { owner: "user@example.com" },
     *   },
     *   actions: ["view", "edit"],
     * });
     *
     * decision.isAllowed("view"); // => true
     * ```
     */
    async checkResource(request, options) {
        const { resource, actions, ...rest } = request;
        const response = await this.checkResources({ resources: [{ resource, actions }], ...rest }, options);
        const result = response.findResult(resource);
        if (!result) {
            throw new Error("No decision returned for resource");
        }
        return result;
    }
    /**
     * Check a principal's permissions on a set of resources.
     *
     * @example
     * ```typescript
     * const decision = await cerbos.checkResources({
     *   principal: {
     *     id: "user@example.com",
     *     roles: ["USER"],
     *     attr: { tier: "PREMIUM" },
     *   },
     *   resources: [
     *     {
     *       resource: {
     *         kind: "document",
     *         id: "1",
     *         attr: { owner: "user@example.com" },
     *       },
     *       actions: ["view", "edit"],
     *     },
     *     {
     *       resource: {
     *         kind: "image",
     *         id: "1",
     *         attr: { owner: "user@example.com" },
     *       },
     *       actions: ["delete"],
     *     },
     *   ],
     * });
     *
     * decision.isAllowed({
     *   resource: { kind: "document", id: "1" },
     *   action: "view",
     * }); // => true
     * ```
     */
    async checkResources(request, options) {
        const response = (0, fromProtobuf_1.checkResourcesResponseFromProtobuf)(await this.cerbos("checkResources", (0, toProtobuf_1.checkResourcesRequestToProtobuf)(request), options));
        this.handleValidationErrors(response);
        return response;
    }
    /**
     * Delete a schema.
     *
     * @remarks
     * Requires
     *
     * - the client to be configured with {@link Options.adminCredentials},
     *
     * - the Cerbos policy decision point (PDP) server to be configured with the {@link https://docs.cerbos.dev/cerbos/latest/api/admin_api | admin API} enabled, and
     *
     * - a dynamic {@link https://docs.cerbos.dev/cerbos/latest/configuration/storage | storage backend}.
     *
     * The way this method handles failure depends on the version of the connected PDP server.
     * When the server is running Cerbos v0.25 or later, it returns `true` if the schema was deleted and `false` if the schema was not found.
     * With earlier versions of Cerbos, it throws an error if the schema was not found, and returns successfully if the schema was deleted; the returned value should be ignored.
     *
     * @example
     * ```typescript
     * const deleted = await cerbos.deleteSchema("document.json");
     * ```
     */
    async deleteSchema(id, options) {
        const { deletedSchemas } = await this.deleteSchemas({ ids: [id] }, options);
        return deletedSchemas === 1;
    }
    /**
     * Delete multiple schemas.
     *
     * @remarks
     * Requires
     *
     * - the client to be configured with {@link Options.adminCredentials},
     *
     * - the Cerbos policy decision point (PDP) server to be configured with the {@link https://docs.cerbos.dev/cerbos/latest/api/admin_api | admin API} enabled, and
     *
     * - a dynamic {@link https://docs.cerbos.dev/cerbos/latest/configuration/storage | storage backend}.
     *
     * The way this method handles failure depends on the version of the connected PDP server.
     * When the server is running Cerbos v0.25 or later, it returns a {@link DeleteSchemasResponse} that includes the number of schemas that were deleted.
     * With earlier versions of Cerbos, it throws an error if no schemas were found, and returns successfully if at least one schema was deleted; the returned value should be ignored.
     *
     * @example
     * ```typescript
     * const result = await cerbos.deleteSchemas({
     *   ids: ["document.json", "image.json"],
     * });
     * ```
     */
    async deleteSchemas(request, options) {
        return (0, fromProtobuf_1.deleteSchemasResponseFromProtobuf)(await this.admin("deleteSchema", (0, toProtobuf_1.deleteSchemasRequestToProtobuf)(request), options));
    }
    /**
     * Disable multiple policies.
     *
     * @remarks
     * Requires
     *
     * - the client to be configured with {@link Options.adminCredentials},
     *
     * - the Cerbos policy decision point server to be at least v0.25 and configured with the {@link https://docs.cerbos.dev/cerbos/latest/api/admin_api | admin API} enabled, and
     *
     * - a dynamic {@link https://docs.cerbos.dev/cerbos/latest/configuration/storage | storage backend}.
     *
     * @example
     * ```typescript
     * const result = await cerbos.disablePolicies({
     *   ids: ["resource.document.v1", "resource.image.v1"],
     * });
     * ```
     */
    async disablePolicies(request, options) {
        return (0, fromProtobuf_1.disablePoliciesResponseFromProtobuf)(await this.admin("disablePolicy", (0, toProtobuf_1.disablePoliciesRequestToProtobuf)(request), options));
    }
    /**
     * Disable a policy.
     *
     * @remarks
     * Requires
     *
     * - the client to be configured with {@link Options.adminCredentials},
     *
     * - the Cerbos policy decision point server to be at least v0.25 and configured with the {@link https://docs.cerbos.dev/cerbos/latest/api/admin_api | admin API} enabled, and
     *
     * - a dynamic {@link https://docs.cerbos.dev/cerbos/latest/configuration/storage | storage backend}.
     *
     * @example
     * ```typescript
     * const disabled = await cerbos.disablePolicy("resource.document.v1");
     * ```
     */
    async disablePolicy(id, options) {
        const { disabledPolicies } = await this.disablePolicies({ ids: [id] }, options);
        return disabledPolicies === 1;
    }
    /**
     * Enable multiple policies.
     *
     * @remarks
     * Requires
     *
     * - the client to be configured with {@link Options.adminCredentials},
     *
     * - the Cerbos policy decision point server to be at least v0.26 and configured with the {@link https://docs.cerbos.dev/cerbos/latest/api/admin_api | admin API} enabled, and
     *
     * - a dynamic {@link https://docs.cerbos.dev/cerbos/latest/configuration/storage | storage backend}.
     *
     * @example
     * ```typescript
     * const result = await cerbos.enablePolicies({
     *   ids: ["resource.document.v1", "resource.image.v1"],
     * });
     * ```
     */
    async enablePolicies(request, options) {
        return (0, fromProtobuf_1.enablePoliciesResponseFromProtobuf)(await this.admin("enablePolicy", (0, toProtobuf_1.enablePoliciesRequestToProtobuf)(request), options));
    }
    /**
     * Enable a policy.
     *
     * @remarks
     * Requires
     *
     * - the client to be configured with {@link Options.adminCredentials},
     *
     * - the Cerbos policy decision point server to be at least v0.26 and configured with the {@link https://docs.cerbos.dev/cerbos/latest/api/admin_api | admin API} enabled, and
     *
     * - a dynamic {@link https://docs.cerbos.dev/cerbos/latest/configuration/storage | storage backend}.
     *
     * @example
     * ```typescript
     * const enabled = await cerbos.enablePolicy("resource.document.v1");
     * ```
     */
    async enablePolicy(id, options) {
        const { enabledPolicies } = await this.enablePolicies({ ids: [id] }, options);
        return enabledPolicies === 1;
    }
    /**
     * Fetch multiple policies by ID.
     *
     * @remarks
     * Requires
     *
     * - the client to be configured with {@link Options.adminCredentials}, and
     *
     * - the Cerbos policy decision point server to be configured with the {@link https://docs.cerbos.dev/cerbos/latest/api/admin_api | admin API} enabled.
     *
     * @example
     * ```typescript
     * const policies = await cerbos.getPolicies({
     *   ids: ["resource.document.v1", "resource.image.v1"],
     * });
     * ```
     */
    async getPolicies(request, options) {
        return (0, fromProtobuf_1.getPoliciesResponseFromProtobuf)(await this.admin("getPolicy", (0, toProtobuf_1.getPoliciesRequestToProtobuf)(request), options));
    }
    /**
     * Fetch a policy by ID.
     *
     * @remarks
     * Requires
     *
     * - the client to be configured with {@link Options.adminCredentials}, and
     *
     * - the Cerbos policy decision point server to be configured with the {@link https://docs.cerbos.dev/cerbos/latest/api/admin_api | admin API} enabled.
     *
     * @example
     * ```typescript
     * const policy = await cerbos.getPolicy("resource.document.v1");
     * ```
     */
    async getPolicy(id, options) {
        const { policies: [policy], } = await this.getPolicies({ ids: [id] }, options);
        return policy;
    }
    /**
     * Fetch a schema by ID.
     *
     * @remarks
     * Requires
     *
     * - the client to be configured with {@link Options.adminCredentials}, and
     *
     * - the Cerbos policy decision point server to be configured with the {@link https://docs.cerbos.dev/cerbos/latest/api/admin_api | admin API} enabled.
     *
     * @example
     * ```typescript
     * const schema = await cerbos.getSchema("document.json");
     * ```
     */
    async getSchema(id, options) {
        const { schemas: [schema], } = await this.getSchemas({ ids: [id] }, options);
        return schema;
    }
    /**
     * Fetch multiple schemas by ID.
     *
     * @remarks
     * Requires
     *
     * - the client to be configured with {@link Options.adminCredentials}, and
     *
     * - the Cerbos policy decision point server to be configured with the {@link https://docs.cerbos.dev/cerbos/latest/api/admin_api | admin API} enabled.
     *
     * @example
     * ```typescript
     * const schemas = await cerbos.getSchemas({
     *   ids: ["document.json", "image.json"],
     * });
     * ```
     */
    async getSchemas(request, options) {
        return (0, fromProtobuf_1.getSchemasResponseFromProtobuf)(await this.admin("getSchema", (0, toProtobuf_1.getSchemasRequestToProtobuf)(request), options));
    }
    /**
     * Check if a principal is allowed to perform an action on a resource.
     *
     * @example
     * ```typescript
     * await cerbos.isAllowed({
     *   principal: {
     *     id: "user@example.com",
     *     roles: ["USER"],
     *     attr: { tier: "PREMIUM" },
     *   },
     *   resource: {
     *     kind: "document",
     *     id: "1",
     *     attr: { owner: "user@example.com" },
     *   },
     *   action: "view",
     * }); // => true
     * ```
     */
    async isAllowed(request, options) {
        const { action, ...rest } = request;
        const result = await this.checkResource({ actions: [action], ...rest }, options);
        const allowed = result.isAllowed(action);
        if (allowed === undefined) {
            throw new Error("No decision returned for action");
        }
        return allowed;
    }
    /**
     * List policies.
     *
     * @remarks
     * Requires
     *
     * - the client to be configured with {@link Options.adminCredentials}, and
     *
     * - the Cerbos policy decision point server to be configured with the {@link https://docs.cerbos.dev/cerbos/latest/api/admin_api | admin API} enabled.
     *
     * @example
     * ```typescript
     * const { ids } = await cerbos.listPolicies();
     * ```
     */
    async listPolicies(request = {}, options) {
        return (0, fromProtobuf_1.listPoliciesResponseFromProtobuf)(await this.admin("listPolicies", (0, toProtobuf_1.listPoliciesRequestToProtobuf)(request), options));
    }
    /**
     * List schemas.
     *
     * @remarks
     * Requires
     *
     * - the client to be configured with {@link Options.adminCredentials}, and
     *
     * - the Cerbos policy decision point server to be configured with the {@link https://docs.cerbos.dev/cerbos/latest/api/admin_api | admin API} enabled.
     *
     * @example
     * ```typescript
     * const { ids } = await cerbos.listSchemas();
     * ```
     */
    async listSchemas(options) {
        return (0, fromProtobuf_1.listSchemasResponseFromProtobuf)(await this.admin("listSchemas", {}, options));
    }
    /**
     * Produce a query plan that can be used to obtain a list of resources on which a principal is allowed to perform a particular action.
     *
     * @example
     * ```typescript
     * const plan = await cerbos.planResources({
     *   principal: {
     *     id: "user@example.com",
     *     roles: ["USER"],
     *     attr: { tier: "PREMIUM" },
     *   },
     *   resource: { kind: "document" },
     *   action: "view",
     * });
     * ```
     */
    async planResources(request, options) {
        const response = (0, fromProtobuf_1.planResourcesResponseFromProtobuf)(await this.cerbos("planResources", (0, toProtobuf_1.planResourcesRequestToProtobuf)(request), options));
        this.handleValidationErrors(response);
        return response;
    }
    /**
     * Reload the store.
     *
     * @remarks
     * Requires
     *
     * - the client to be configured with {@link Options.adminCredentials},
     *
     * - the Cerbos policy decision point server to be configured with the {@link https://docs.cerbos.dev/cerbos/latest/api/admin_api | admin API}, and
     *
     * - a reloadable {@link https://docs.cerbos.dev/cerbos/latest/configuration/storage | storage backend}.
     *
     * @example
     * ```typescript
     * await cerbos.reloadStore({ wait: true });
     * ```
     */
    async reloadStore(request, options) {
        await this.admin("reloadStore", request, options);
    }
    /**
     * Retrieve information about the Cerbos policy decision point server.
     */
    async serverInfo(options) {
        return await this.cerbos("serverInfo", {}, options);
    }
    async admin(rpc, request, options) {
        return await this.send("admin", rpc, request, this.options.adminCredentials, options);
    }
    async cerbos(rpc, request, options) {
        return await this.send("cerbos", rpc, request, undefined, options);
    }
    async send(service, rpc, request, adminCredentials, { headers } = {}) {
        return await this.transport(service, rpc, request, await this.mergeHeaders(headers, adminCredentials));
    }
    async mergeHeaders(override, adminCredentials) {
        const init = this.options.headers;
        const headers = new Headers(typeof init === "function" ? await init() : init);
        if (adminCredentials) {
            headers.set("Authorization", `Basic ${btoa(`${adminCredentials.username}:${adminCredentials.password}`)}`);
        }
        if (this.options.playgroundInstance) {
            headers.set("Playground-Instance", this.options.playgroundInstance);
        }
        if (override) {
            for (const [name, value] of new Headers(override)) {
                headers.set(name, value);
            }
        }
        return headers;
    }
    handleValidationErrors({ validationErrors, }) {
        const { onValidationError } = this.options;
        if (onValidationError) {
            if (validationErrors.length > 0) {
                if (onValidationError === "throw") {
                    throw new errors_1.ValidationFailed(validationErrors);
                }
                onValidationError(validationErrors);
            }
        }
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map