"use strict";
/**
 * Client library for interacting with the Cerbos policy decision point service over gRPC from server-side Node.js applications.
 *
 * @packageDocumentation
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GRPC = void 0;
const core_1 = require("@cerbos/core");
const grpc_js_1 = require("@grpc/grpc-js");
const svc_1 = require("./protobuf/cerbos/svc/v1/svc");
// eslint-disable-next-line @typescript-eslint/no-var-requires -- Can't import package.json because it is outside of the project's rootDir
const { version } = require("../package.json");
const defaultUserAgent = `cerbos-sdk-javascript-grpc/${version}`;
/**
 * A client for interacting with the Cerbos policy decision point server over gRPC.
 *
 * @remarks
 * Not supported in browsers.
 *
 * See {@link @cerbos/core#Client | the parent class} for available methods.
 *
 * @public
 */
class GRPC extends core_1.Client {
    client;
    /**
     * Create a client for interacting with the Cerbos policy decision point (PDP) server over gRPC.
     *
     * @param target - Cerbos PDP server address (`"host"`, `"host:port"`, or `"unix:/path/to/socket"`).
     * @param options - additional client settings.
     *
     * @example
     * Connect via TCP with no encryption:
     *
     * ```typescript
     * const cerbos = new GRPC("localhost:3593", { tls: false });
     * ```
     *
     * @example
     * Connect via a Unix socket with no encryption:
     *
     * ```typescript
     * const cerbos = new GRPC("unix:/var/run/cerbos.grpc.sock", { tls: false });
     * ```
     *
     * @example
     * Connect to the hosted demo PDP to experiment {@link https://play.cerbos.dev | in the playground}:
     *
     * ```typescript
     * const cerbos = new GRPC("demo-pdp.cerbos.cloud", { tls: true, playgroundInstance: "gE623b0180QlsG5a4QIN6UOZ6f3iSFW2" });
     * ```
     */
    constructor(target, options) {
        const credentials = channelCredentials(options);
        const client = new grpc_js_1.Client(target, credentials, {
            "grpc.primary_user_agent": `${options.userAgent ? `${options.userAgent} ` : ""}${defaultUserAgent}`,
        });
        super(async (service, rpc, request, headers) => {
            const { path, requestSerialize, responseDeserialize } = services[service][rpc]; // https://github.com/microsoft/TypeScript/issues/30581
            const callOptions = {};
            const metadata = new grpc_js_1.Metadata();
            for (const [hame, value] of headers) {
                metadata.set(hame, value);
            }
            return await new Promise((resolve, reject) => {
                client.makeUnaryRequest(path, requestSerialize, responseDeserialize, request, metadata, callOptions, (error, response) => {
                    if (error) {
                        reject(new core_1.NotOK((error.code || core_1.Status.UNKNOWN), error.details));
                    }
                    else if (!response) {
                        reject(new core_1.NotOK(core_1.Status.UNKNOWN, "No response received"));
                    }
                    else {
                        resolve(response);
                    }
                });
            });
        }, options);
        this.client = client;
    }
    /**
     * Disconnect from the Cerbos policy decision point server and clean up resources.
     *
     * @remarks
     * It is safe to call `close` more than once.
     *
     * Any interactions with the server after calling `close` will throw an error.
     */
    close() {
        this.client.close();
    }
}
exports.GRPC = GRPC;
const services = {
    admin: svc_1.CerbosAdminServiceService,
    cerbos: svc_1.CerbosServiceService,
};
function channelCredentials({ playgroundInstance, tls, }) {
    if (!tls) {
        if (playgroundInstance) {
            throw new Error("TLS is required when connecting to a playground instance");
        }
        return grpc_js_1.ChannelCredentials.createInsecure();
    }
    if (tls === true) {
        return grpc_js_1.ChannelCredentials.createSsl();
    }
    return grpc_js_1.ChannelCredentials.createFromSecureContext(tls);
}
//# sourceMappingURL=index.js.map