import _m0 from "protobufjs/minimal";
import { Duration } from "../google/protobuf/duration";
export declare const protobufPackage = "validate";
export declare enum KnownRegex {
    UNKNOWN = 0,
    HTTP_HEADER_NAME = 1,
    HTTP_HEADER_VALUE = 2
}
export interface FieldRules {
    message: MessageRules | undefined;
    type?: {
        $case: "float";
        float: FloatRules;
    } | {
        $case: "double";
        double: DoubleRules;
    } | {
        $case: "int32";
        int32: Int32Rules;
    } | {
        $case: "int64";
        int64: Int64Rules;
    } | {
        $case: "uint32";
        uint32: UInt32Rules;
    } | {
        $case: "uint64";
        uint64: UInt64Rules;
    } | {
        $case: "sint32";
        sint32: SInt32Rules;
    } | {
        $case: "sint64";
        sint64: SInt64Rules;
    } | {
        $case: "fixed32";
        fixed32: Fixed32Rules;
    } | {
        $case: "fixed64";
        fixed64: Fixed64Rules;
    } | {
        $case: "sfixed32";
        sfixed32: SFixed32Rules;
    } | {
        $case: "sfixed64";
        sfixed64: SFixed64Rules;
    } | {
        $case: "bool";
        bool: BoolRules;
    } | {
        $case: "string";
        string: StringRules;
    } | {
        $case: "bytes";
        bytes: BytesRules;
    } | {
        $case: "enum";
        enum: EnumRules;
    } | {
        $case: "repeated";
        repeated: RepeatedRules;
    } | {
        $case: "map";
        map: MapRules;
    } | {
        $case: "any";
        any: AnyRules;
    } | {
        $case: "duration";
        duration: DurationRules;
    } | {
        $case: "timestamp";
        timestamp: TimestampRules;
    } | undefined;
}
export interface FloatRules {
    const: number;
    lt: number;
    lte: number;
    gt: number;
    gte: number;
    in: number[];
    notIn: number[];
    ignoreEmpty: boolean;
}
export interface DoubleRules {
    const: number;
    lt: number;
    lte: number;
    gt: number;
    gte: number;
    in: number[];
    notIn: number[];
    ignoreEmpty: boolean;
}
export interface Int32Rules {
    const: number;
    lt: number;
    lte: number;
    gt: number;
    gte: number;
    in: number[];
    notIn: number[];
    ignoreEmpty: boolean;
}
export interface Int64Rules {
    const: string;
    lt: string;
    lte: string;
    gt: string;
    gte: string;
    in: string[];
    notIn: string[];
    ignoreEmpty: boolean;
}
export interface UInt32Rules {
    const: number;
    lt: number;
    lte: number;
    gt: number;
    gte: number;
    in: number[];
    notIn: number[];
    ignoreEmpty: boolean;
}
export interface UInt64Rules {
    const: string;
    lt: string;
    lte: string;
    gt: string;
    gte: string;
    in: string[];
    notIn: string[];
    ignoreEmpty: boolean;
}
export interface SInt32Rules {
    const: number;
    lt: number;
    lte: number;
    gt: number;
    gte: number;
    in: number[];
    notIn: number[];
    ignoreEmpty: boolean;
}
export interface SInt64Rules {
    const: string;
    lt: string;
    lte: string;
    gt: string;
    gte: string;
    in: string[];
    notIn: string[];
    ignoreEmpty: boolean;
}
export interface Fixed32Rules {
    const: number;
    lt: number;
    lte: number;
    gt: number;
    gte: number;
    in: number[];
    notIn: number[];
    ignoreEmpty: boolean;
}
export interface Fixed64Rules {
    const: string;
    lt: string;
    lte: string;
    gt: string;
    gte: string;
    in: string[];
    notIn: string[];
    ignoreEmpty: boolean;
}
export interface SFixed32Rules {
    const: number;
    lt: number;
    lte: number;
    gt: number;
    gte: number;
    in: number[];
    notIn: number[];
    ignoreEmpty: boolean;
}
export interface SFixed64Rules {
    const: string;
    lt: string;
    lte: string;
    gt: string;
    gte: string;
    in: string[];
    notIn: string[];
    ignoreEmpty: boolean;
}
export interface BoolRules {
    const: boolean;
}
export interface StringRules {
    const: string;
    len: string;
    minLen: string;
    maxLen: string;
    lenBytes: string;
    minBytes: string;
    maxBytes: string;
    pattern: string;
    prefix: string;
    suffix: string;
    contains: string;
    notContains: string;
    in: string[];
    notIn: string[];
    wellKnown?: {
        $case: "email";
        email: boolean;
    } | {
        $case: "hostname";
        hostname: boolean;
    } | {
        $case: "ip";
        ip: boolean;
    } | {
        $case: "ipv4";
        ipv4: boolean;
    } | {
        $case: "ipv6";
        ipv6: boolean;
    } | {
        $case: "uri";
        uri: boolean;
    } | {
        $case: "uriRef";
        uriRef: boolean;
    } | {
        $case: "address";
        address: boolean;
    } | {
        $case: "uuid";
        uuid: boolean;
    } | {
        $case: "wellKnownRegex";
        wellKnownRegex: KnownRegex;
    } | undefined;
    strict: boolean;
    ignoreEmpty: boolean;
}
export interface BytesRules {
    const: Uint8Array;
    len: string;
    minLen: string;
    maxLen: string;
    pattern: string;
    prefix: Uint8Array;
    suffix: Uint8Array;
    contains: Uint8Array;
    in: Uint8Array[];
    notIn: Uint8Array[];
    wellKnown?: {
        $case: "ip";
        ip: boolean;
    } | {
        $case: "ipv4";
        ipv4: boolean;
    } | {
        $case: "ipv6";
        ipv6: boolean;
    } | undefined;
    ignoreEmpty: boolean;
}
export interface EnumRules {
    const: number;
    definedOnly: boolean;
    in: number[];
    notIn: number[];
}
export interface MessageRules {
    skip: boolean;
    required: boolean;
}
export interface RepeatedRules {
    minItems: string;
    maxItems: string;
    unique: boolean;
    items: FieldRules | undefined;
    ignoreEmpty: boolean;
}
export interface MapRules {
    minPairs: string;
    maxPairs: string;
    noSparse: boolean;
    keys: FieldRules | undefined;
    values: FieldRules | undefined;
    ignoreEmpty: boolean;
}
export interface AnyRules {
    required: boolean;
    in: string[];
    notIn: string[];
}
export interface DurationRules {
    required: boolean;
    const: Duration | undefined;
    lt: Duration | undefined;
    lte: Duration | undefined;
    gt: Duration | undefined;
    gte: Duration | undefined;
    in: Duration[];
    notIn: Duration[];
}
export interface TimestampRules {
    required: boolean;
    const: Date | undefined;
    lt: Date | undefined;
    lte: Date | undefined;
    gt: Date | undefined;
    gte: Date | undefined;
    ltNow: boolean;
    gtNow: boolean;
    within: Duration | undefined;
}
export declare const FieldRules: {
    encode(message: FieldRules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FieldRules;
};
export declare const FloatRules: {
    encode(message: FloatRules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FloatRules;
};
export declare const DoubleRules: {
    encode(message: DoubleRules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DoubleRules;
};
export declare const Int32Rules: {
    encode(message: Int32Rules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Int32Rules;
};
export declare const Int64Rules: {
    encode(message: Int64Rules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Int64Rules;
};
export declare const UInt32Rules: {
    encode(message: UInt32Rules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UInt32Rules;
};
export declare const UInt64Rules: {
    encode(message: UInt64Rules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UInt64Rules;
};
export declare const SInt32Rules: {
    encode(message: SInt32Rules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SInt32Rules;
};
export declare const SInt64Rules: {
    encode(message: SInt64Rules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SInt64Rules;
};
export declare const Fixed32Rules: {
    encode(message: Fixed32Rules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Fixed32Rules;
};
export declare const Fixed64Rules: {
    encode(message: Fixed64Rules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Fixed64Rules;
};
export declare const SFixed32Rules: {
    encode(message: SFixed32Rules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SFixed32Rules;
};
export declare const SFixed64Rules: {
    encode(message: SFixed64Rules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SFixed64Rules;
};
export declare const BoolRules: {
    encode(message: BoolRules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BoolRules;
};
export declare const StringRules: {
    encode(message: StringRules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StringRules;
};
export declare const BytesRules: {
    encode(message: BytesRules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BytesRules;
};
export declare const EnumRules: {
    encode(message: EnumRules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EnumRules;
};
export declare const MessageRules: {
    encode(message: MessageRules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MessageRules;
};
export declare const RepeatedRules: {
    encode(message: RepeatedRules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RepeatedRules;
};
export declare const MapRules: {
    encode(message: MapRules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MapRules;
};
export declare const AnyRules: {
    encode(message: AnyRules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AnyRules;
};
export declare const DurationRules: {
    encode(message: DurationRules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DurationRules;
};
export declare const TimestampRules: {
    encode(message: TimestampRules, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TimestampRules;
};
//# sourceMappingURL=validate.d.ts.map